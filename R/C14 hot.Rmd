---
title: "C14 hot data"
author: "Denise Ong"
date: "4/2/2020"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE,
                        tidy=FALSE)
```

```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
library(broom)
```

# Denise edits on 7 Dec 2020

The following edits have been made to the data:
•	Exp 3: SUR: pico: vial A – remove
•	Add Exp 8: SUR: nano – for vial B and D, there is cells sorted for both 1000 and 2000. Move to syn and pico calculations for lm value.
•	exp 5: SUR. Vial D is high. Also marked in the excel sheet. Removed, to be checked by Andres/Karl side.
•	Exp 6: SUR: nano – repeated vial A, remove lower value
•	Exp 7: SUR: nano – remove (Dark incubation is much higher than A, B, C)
•	Exp 7: DCM: nano – remove (Dark incubation is much higher than A, B, C)
•	Exp 8: DCM: nano – remove 
•	Exp 8: SUR: nano: 2000 cell count – remove
• Moved Exp 2: DCM: pico vial A from pico/syn calculation (part 1) to nano calculation (part 2). only 1 value, cells sorted 1120.
•	Moved Exp 8: SUR: nano – for vial B and D from nano calculation (part 2) to pico/syn calculation (part 1) for lm value, as there is cells sorted for both 1000 and 2000.
•	Exp 6: SUR: vial C, error in recording. Changed in excel sheet so excel sheet name used changed from "TAN1810_14C-Pico_25052020_QA.xlsx" to "TAN1810_14C-Pico_25052020_QA_1.0.xlsx"
•	Exp 4: SUR: pico, syn – repeated vial B, take the average of the dpm value
•	Exp 4: SUR: nano – repeated vial B, take the average of the dpm value
•	Exp 1: SUR: nano – vial C and D swap dpm value


The calculations of primary production are based on single cell C14 uptake for cells sorted by flow cytometry. (https://vaulot.netlify.app/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/)
To calculate the pp values, pico and syn had cell counts of 2000, 4000, 10000. The gradient of the lm is calculated by grouping vials A, B, C together to get the DPM per cell for each experiment. For nano, the cells were sorted mostly with one cell count of 2000. The DPM per cell is calculated by the average of vial A, B, C to get the value for each experiment. 


# 1. Calculations for pico and syn - Compute lm by grouping ABC together

The following edits made to pico and syn data:
•	Exp 3: SUR: pico: vial A – remove
• Exp 2: DCM: pico vial A- only 1 value, cells sorted 1120. Moved to part 2 (nano calculations) for average value instead of lm value.
•	Add Exp 8: SUR: nano – for vial B and D, there is cells sorted for both 1000 and 2000. Move to syn and pico calculations for lm value.
•	Exp 4: SUR: pico, syn – repeated vial B, take the average of the dpm value

## Read table for pico and syn. Data points to edit are made here. 
```{r}
C14_DPM <- readxl::read_excel("../data_used/TAN1810_14C-Pico_25052020_QA_1.0.xlsx", sheet = "Complete data TAN1810", skip = 11) %>%
  dplyr::select (`Cycle#`, `EXP#`, SAMPLE, `Vial code             (i - initials, A to C - light incubation, D - dark)`, `sorting population`, `Cells sorted`, DPM1, DIC, `SA_dpm_mL`) %>%   
     rename(cycle = `Cycle#`,
            exp = `EXP#`,
            sample = SAMPLE, 
            vial = `Vial code             (i - initials, A to C - light incubation, D - dark)`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1,
            SA = `SA_dpm_mL`) %>%
    filter(population != "Nano" | (population == "Nano" & exp == 8 & sample == "SUR" & vial == "B") | (population == "Nano" & exp == 8 & sample == "SUR" & vial == "D")) %>%
    filter(!(exp == 3 & sample == "SUR" & vial == "A" & population == "Pico")) %>%
    filter(!(exp == 2 & sample == "DCM" & vial == "A" & population == "Pico")) %>%
     group_by(cycle, exp, sample, vial, population, cells_sorted) %>% 
     summarize(cells_sorted = mean(cells_sorted),
               dpm= mean(dpm),
               DIC = mean(DIC),
               SA = mean(SA)) %>%
    ungroup()

C14_DPM
```

## Subtract the dark DPM
Join tables based on common variables

```{r}
C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  dplyr::select(-vial) # Remove the vial column
C14_DPM_Dark
# Check the values of dpm dark with histogram. The values are normally distributed, concentrated around the mean.
hist(C14_DPM_Dark$dpm_dark)
mean(C14_DPM_Dark$dpm_dark)
```

```{r}
C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark) %>% 
  filter (vial != "D") %>% 
  # DV - The next line replace dpm_dark to average dpm_dark if no value. Checked with histogram above.
  mutate(dpm_dark = case_when (is.na(dpm_dark) ~ mean(dpm_dark, na.rm = TRUE),
                               TRUE ~ dpm_dark))  %>% 
  # DV - The next line set dpm_correct to zero if negative, as negative values are all close to zero.
  mutate(dpm_corrected = case_when (dpm >= dpm_dark ~ dpm - dpm_dark,
                                    TRUE ~0)) 

C14_DPM_corrected  
```

## Plots

Do plots for each group. One regression line based on the EXP, Sample and Populations
```{r fig.height=15, fig.width=10}
 reg_plot <- ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
reg_plot
```

## Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
C14_DPM_model_1 <- C14_DPM_corrected %>%
  group_by(cycle, exp, sample, population, DIC, SA) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_1 <- C14_DPM_model_1 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_1
  
```


## Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
pp_cal_1 <- mutate(C14_DPM_model_output_1, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal_1 <- complete(pp_cal_1, nesting(cycle, exp, sample), population) 
  
pp_cal_1
```

# 2. Calculations for Nano (average)

Data points to check for Nano calculations:
•	exp 5: SUR. Vial D is high. Also marked in the excel sheet. Removed, to be checked by Andres/Karl side.


The following edits made to Nano data:
•	Exp 6: SUR: nano – repeated vial A, remove lower value
•	Exp 7: SUR: nano – remove (Dark incubation is much higher than A, B, C)
•	Exp 7: DCM: nano – remove (Dark incubation is much higher than A, B, C)
•	Exp 8: DCM: nano – remove 
•	Exp 8: SUR: nano: 2000 cell count – remove
• exp 2: DCM: nano. cells sorted for vial A is 496. 
• Added Exp 2: DCM: pico vial A- only 1 value, cells sorted 1120.
<<<<<<< Updated upstream
•	Exp 8: SUR: nano – for vial B and D, there is cells sorted for both 1000 and 2000. Move to syn and pico calculations for lm value.
=======
•	Moved Exp 8: SUR: nano – for vial B and D, there is cells sorted for both 1000 and 2000. Move to syn and pico calculations for lm value.


Edits to be made:
>>>>>>> Stashed changes
•	Exp 1: SUR: nano – value for dpm for vial C and D swap
•	Exp 4: SUR: nano – repeated vial B, take the average of the dpm value
      
      
```{r}
# Changed the excel sheet read, with final dpm and DIC values
C14_DPM_nano <- readxl::read_excel("TAN1810_14C-Pico_25052020_QA_1.0.xlsx", sheet = "Complete data TAN1810", skip = 11)%>% 
  dplyr::select (`Cycle#`, `EXP#`, SAMPLE, `Vial code             (i - initials, A to C - light incubation, D - dark)`, `sorting population`, `Cells sorted`, DPM1, DIC, `SA_dpm_mL`) %>%   
     rename(cycle = `Cycle#`,
            exp = `EXP#`,
            sample = SAMPLE, 
            vial = `Vial code             (i - initials, A to C - light incubation, D - dark)`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1,
            SA = `SA_dpm_mL`) %>%
    filter(population == "Nano" | (exp == 2 & sample == "DCM" & vial == "A" & population == "Pico")) %>%
    filter(!(exp == 5 & sample == "SUR" & vial =="D")) %>%
    filter(!(exp == 7 & sample == "SUR")) %>%
    filter(!(exp == 7 & sample == "DCM")) %>%
    filter(!(exp == 8 & sample == "DCM")) %>%
    filter(!(exp == 8 & sample == "SUR" & vial == "C" & cells_sorted == 2000)) %>%
    filter(!(exp == 6 & sample == "SUR" & vial == "A" & dpm == 384)) %>%
    filter(!(exp == 8 & sample == "SUR" & vial == "B")) %>%
    filter(!(exp == 8 & sample == "SUR" & vial == "D" & cells_sorted == 2000)) %>% 
    mutate(vial = case_when((exp == 1 & sample == "SUR" & vial == "C") ~ "D",
                            (exp == 1 & sample == "SUR" & vial == "D") ~ "C",
                            TRUE ~ vial)) %>% 
   group_by(cycle, exp, sample, vial, population, cells_sorted) %>% 
   summarize(cells_sorted = mean(cells_sorted),
             dpm= mean(dpm),
             DIC = mean(DIC),
             SA = mean(SA)) %>%
    ungroup()

C14_DPM_nano
```

## Substract the dark DPM
Join tables based on common variables

```{r}
 C14_DPM_Dark_nano <- C14_DPM_nano %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  dplyr::select(-vial)  # Remove the vial column
C14_DPM_Dark_nano
# Check the values of dpm dark with histogram.
hist(C14_DPM_Dark_nano$dpm_dark)
mean(C14_DPM_Dark_nano$dpm_dark)
```
```{r}
C14_DPM_corrected_nano <- left_join(C14_DPM_nano,C14_DPM_Dark_nano) %>% 
  filter (vial != "D") %>% 
  # DV - The next line replace dpm_dark to average dpm_dark if no value. Checked with histogram above.
  mutate(dpm_dark = case_when (is.na(dpm_dark) ~ mean(dpm_dark, na.rm = TRUE),
                               TRUE ~ dpm_dark))  %>% 
  # DV - The next line set dpm_correct to zero if negative, as negative values are all close to zero.
  mutate(dpm_corrected = case_when (dpm >= dpm_dark ~ dpm - dpm_dark,
                                    TRUE ~0)) 
C14_DPM_corrected_nano
```

## calculate mean
```{r}
# merge tables
pp_cal_nano <-  C14_DPM_corrected_nano %>%
  group_by(SA, population, cycle, DIC, exp, sample) %>%
  mutate(mean_dpm_corrected=mean(dpm_corrected)) %>% #calculate mean
  select(-vial, -dpm, -dpm_dark, -dpm_corrected) %>%
  distinct() #remove duplicates

pp_cal_nano
```

## Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r} 
pp_cal_nano <- mutate(pp_cal_nano, pp = DIC*mean_dpm_corrected*(1/(SA*24*cells_sorted))*10^9*1.05) %>% 
  ungroup() %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal_nano <- complete(pp_cal_nano, nesting(cycle, exp, sample), population) %>%
  select(-SA, -DIC)%>%
  ungroup()
  
pp_cal_nano
```


# 3. Join pico, syn and nano values together

```{r}
pp_cal_1_join<-full_join(pp_cal_1,pp_cal_nano) %>%
  select(-SA,-intercept, -slope, -DIC, -cells_sorted, -mean_dpm_corrected)%>%
  arrange(cycle, exp, sample, population) %>%
  tidyr::drop_na()
pp_cal_1_join
pp_cal_1_join$cycle <- as.character(pp_cal_1_join$cycle) 
pp_cal_1_join$exp <- as.character(pp_cal_1_join$exp)
```

## Summary
```{r}
pp_cal_table <- pp_cal_1_join %>% 
  group_by(population,sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE),
            ssd = sd(pp, na.rm = TRUE),
            count = n()) %>%
  mutate(se = ssd / sqrt(count),
        lower_CI = pp_mean - qt(1 - (0.05 / 2), count - 1) * se,
        upper_CI = pp_mean + qt(1 - (0.05 / 2), count - 1) * se) %>%
  select(population, sample, pp_mean, se, lower_CI, upper_CI)%>%
  rename(Population = population,
         Depth = sample,
         `Mean primary production rate (fgC/h/cell)` = pp_mean,
         `Standard error` = se,
         `Lower CI` = lower_CI,
         `Upper CI` = upper_CI)

pp_cal_point <- pp_cal_1_join %>% 
  ggplot() +
  geom_point(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")

pp_cal_boxplot <- pp_cal_1_join %>% 
  ggplot() +
  geom_boxplot(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample") +
 # scale_y_continuous(trans='log10')+
  ylab("pp")

pp_cal_table
pp_cal_point
pp_cal_boxplot
```

The units for pp is fgC/h/cell.
Rii (2016) finds 5–11 fmol C/cell/day for Syn which corresponds to 60-132 fg /day/cell ie 2.5 to 5.5 fg/h/cell.



```{r}
library(xtable)
print(xtable(pp_cal_table),
      comment = FALSE)
```

# Analysis based on ST and SA waters
Subtropical waters- Cycle 3 and 4
Subatlantic waters - Cycle 1, 2 and 5
```{r}
pp_cal_1_join$cycle <- factor(pp_cal_1_join$cycle,levels = c("3", "4", "1", "2", "5"))
pp_cal_rename <- 
cycle_boxplot <- ggplot(pp_cal_1_join, aes(x = cycle, y=pp, fill=population)) +
                 geom_boxplot() + 
                 scale_y_continuous(trans='log10') +
                 ylab("Primary Production (fgC/h/cell)") +
                 xlab("Cycle")+
                 labs(fill= "Sorted cells")+
                theme_minimal()

cycle_boxplot
cycle_table <- pp_cal_1_join %>% 
  group_by(cycle, population) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE)) %>%
  pivot_wider(names_from = cycle, values_from = pp_mean)
cycle_table

pp_cal_1_join$exp <- factor(pp_cal_1_join$exp,levels = c("3", "4", "5", "6", "7", "8", "1", "2", "9", "10", "11"))
exp_boxplot <- ggplot(pp_cal_1_join, aes(x = exp, y=pp, fill=population)) +
                 geom_boxplot() + 
                 scale_y_continuous(trans='log10') +
                 ylab("Primary Production (fgC/h/cell)") 
exp_boxplot
controlling overall appearence, r cookbook
theme_bw
facet_wrap

david mah code from green edge    

counter plot for nutrients
```

# Analysis based on Surface vs DCM
```{r}

depth_boxplot <- ggplot(pp_cal_1_join, aes(x = sample, y=pp, fill=population)) +
                 geom_boxplot() + 
                 scale_y_continuous(trans='log10') +
                 ylab("Primary Production (fgC/h/cell)") 
                 
        
depth_boxplot

depth_table_1 <- pp_cal_1_join %>% 
  group_by(cycle, sample, population) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE)) %>%
  pivot_wider(names_from = cycle, values_from = pp_mean)
depth_table_1
depth_table_2 <- pp_cal_1_join %>% 
  group_by(cycle, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE)) %>%
  pivot_wider(names_from = cycle, values_from = pp_mean)
depth_table_2

```
# NA: Compute based on Method 2 - Compute lm for  ABC separately

Not using this method.

## Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r fig.height=15, fig.width=10}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  # DV - Set the y_scale to free so that graph is more easy to read
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
```



## Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_2 <- C14_DPM_corrected %>%
  group_by(cycle, exp, station, depth, sample, population, vial, SA) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_2 <- C14_DPM_model_2 %>% 
  dplyr::select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_2
  
```


## Merge DIC/SA table and DPM output
```{r}
# merge tables
pp_cal_2 <- left_join(C14_DPM_model_output_2, DIC_data_corrected)
pp_cal_2
```

## Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
pp_cal_2 <- mutate(pp_cal_2, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%
  select( -c(station, depth)) %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal_2 <- complete(pp_cal_2, nesting(cycle, exp, sample), vial, population) 
  
pp_cal_2
```


Compute means quickly.

```{r}
 
pp_cal_2 %>% 
  group_by(population, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE))

pp_cal_2 %>% 
  ggplot() +
  geom_point(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")

pp_cal_2 %>% 
  ggplot() +
  geom_boxplot(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")
```

The units for pp is fgC/h/cell.
Rii (2016) finds 5–11 fmol C/cell/day for Syn which corresponds to 60-132 fg /day/cell ie 2.5 to 5.5 fg/h/cell.
