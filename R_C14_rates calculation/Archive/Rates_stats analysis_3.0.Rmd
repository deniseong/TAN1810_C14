---
title: "Rates_stats analysis_3.0"
author: "Denise Ong"
date: "11/2/2022"
output: html_document
---
Start off with analysis of pp values. If it works then replicate the same analysis for npp values.
test for linear model. Does not work super well because of the decrease in SA1


```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE,
                        tidy = FALSE)
```

```{r}
library(here)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(lme4)
library(car)

source(here("init_files", "init.R")) #for libraries
source(here("init_files", "init_markdown.R")) #for markdown libraries

```

# Read data
```{r}
rates_data <- readxl::read_excel(here("group_rates_output", "Rates_cell_npp_method2.xlsx")) %>%
  #dplyr::select(cycle:population, pp, conc_ml, npp) %>%
  mutate(cycle_name = dplyr::recode(cycle, "1" = "SA1",
                                    "2" = "SA2",
                                    "3" = "ST1",
                                    "4" = "ST2",
                                    "5" = "SA3")) %>%
  mutate(cycle_level = dplyr::recode(cycle_name, "ST1" = "1", #to change the cycle to a gradient 
                                          "ST2" = "2", 
                                          "SA1" = "3",
                                          "SA2" = "4",
                                          "SA3" = "5"))   %>%
  # mutate(water_mass = dplyr::recode(cycle, "1" = "SA-coastal",
  #                                   "2" = "SA",
  #                                   "3" = "ST",
  #                                   "4" = "ST",
  #                                   "5" = "SA"))  %>%
  mutate(log_npp = log10(npp)) %>%
  mutate(log_pp = log10(pp))

rates_data_sub <-  rates_data %>%
  filter(cycle_level != "SA1")

rates_data$cycle_level <- as.numeric(rates_data$cycle_level) #change the cycle to a continuous variable
```

```{r}
lm <- lm(log10(pp) ~ population, data=rates_data_sub)
Anova(lm, type = "3")
pairwise.t.test(rates_data$log_pp, rates_data$population, p.adj='bonferroni')

```

## t test for PP to check if ST is different from SA
```{r}
library("ggpubr")

for (i in c("Syn", "Pico", "Nano")) {
t_test_df<- rates_data_sub %>%
  filter(population == i) %>%
  select(water_mass, pp)

summary <- t_test_df %>%
  group_by(water_mass) %>%
  summarise(count = n(),
    mean = mean(pp, na.rm = TRUE),
    sd = sd(pp, na.rm = TRUE))
print(summary)
 p <- t_test_df %>%
   ggplot(aes(x=water_mass, y=pp)) + geom_point() +geom_boxplot()+ scale_y_continuous(trans='log10') + annotation_logticks(sides = "l")  
 print(p)

#Because p value <0.05, data is not normally distributed. Use the wilcoxon test
p<-with(t_test_df, shapiro.test(pp[water_mass == "ST"]))
print(p)
p<-with(t_test_df, shapiro.test(pp[water_mass == "SA"]))
print(p)
res <- wilcox.test(pp ~ water_mass, data = t_test_df,
                   exact = FALSE)
print(res)
}
```
# NPP
```{r}
hist(rates_data$npp)
qqnorm(rates_data$npp)
shapiro.test(rates_data$npp)

hist(rates_data$log_npp)
qqnorm(rates_data$log_npp)
shapiro.test(rates_data$log_npp)

lm <- lm(log_npp ~ population, data=rates_data)
Anova(lm, type = "3")
pairwise.t.test(rates_data$log_npp, rates_data$population, p.adj='bonferroni')

#not normal distribution. ignore this test.
for (i in c("ST", "SA")) {
  df <- rates_data %>%
    filter(water_mass == i)
  hist(log10(df$npp))
  qqnorm(log10(df$npp))
  print(shapiro.test(log10(df$npp)))
  
  lm <- lm(log10(npp) ~ population, data=df)
  print(Anova(lm, type = "3"))
  print(pairwise.t.test(log10(df$npp), df$population, p.adj='bonferroni'))
}

for (i in c("ST", "SA")) {
  df <- rates_data %>%
    filter(water_mass == i)
  print(
    kruskal.test(npp~population, data = df)
    )#significant. followed by dunn pairwise test
  # print(
  #   pairwise.wilcox.test(df$npp, df$population,
  #                    p.adjust.method = "BH")
  # )
  library(FSA)
s
#perform Dunn's Test with Bonferroni correction for p-values
print(
  dunnTest(npp~population, data = df,
         method="bonferroni")
)
}
```
# T test for NPP
```{r}
library("ggpubr")

for (i in c("Syn", "Pico", "Nano")) {
t_test_df<- rates_data_sub %>%
  filter(population == i) %>%
  select(water_mass, npp) %>%
  mutate(log_npp = log10(npp))

summary <- t_test_df %>%
  group_by(water_mass) %>%
  summarise(count = n(),
    mean = mean(npp, na.rm = TRUE),
    median = median(npp, na.rm = TRUE),
    sd = sd(npp, na.rm = TRUE))
print(summary)
 p <- t_test_df %>%
   ggplot(aes(x=water_mass, y=npp)) + geom_boxplot()+geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l")  
 print(p)

#Because p value <0.05, data is not normally distributed. Use the wilcoxon test
p<-with(t_test_df, shapiro.test(npp[water_mass == "ST"]))
print(p)
p<-with(t_test_df, shapiro.test(npp[water_mass == "SA"]))
print(p)

# res.ftest <- var.test(log_npp ~ water_mass, data = t_test_df)
# print(res.ftest)

res <- wilcox.test(npp ~ water_mass, data = t_test_df,
                   exact = FALSE)
print(res)

# res <- t.test(log_npp ~ water_mass, data = t_test_df, var.equal = TRUE)
# print(res)
}
```

separate the population to do analysis

#LM test
## Syn
```{r}
syn <- rates_data %>%
  filter(population == "Syn") %>%
  mutate(log_pp = log10(pp))
```

## visualise raw data
data looks skewed. shapiro test  p= <0.01, data is not normally distributed. Need to log transform
```{r}
hist(syn$pp)
qqnorm(syn$pp) + qqline(syn$pp)
shapiro.test(syn$pp)

hist(syn$log_pp)
qqnorm(syn$log_pp) + qqline(syn$log_pp)
shapiro.test(syn$log_pp)
```
First, I visualise the data without considering the random effects.
```{r}
ggplot(syn, aes(x=depth, y=pp)) + geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") 
ggplot(syn, aes(x=depth, y=npp)) + geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") 
ggplot(syn, aes(x=cycle_level, y=pp, colour = depth)) +geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") + geom_smooth(method = 'lm') 
```

based on levene test, log transform pp variances between the samples are equal. 
```{r}
leveneTest(syn$log_pp, syn$depth)
```
test if the effect of depth is signficiant
starting model is pp ~ depth * cycle_level (cycle is a continuous variable)

No signficiant difference between depth*cycle and depth + cycle_level (p=0.07)
No significant difference between depth +cycle and cycle (p=0.05)
```{r}
syn_lm1 <- lm(log_pp ~ depth * water_mass, data=syn)
syn_lm2 <- lm(log_pp ~ depth + water_mass, data=syn)

syn_lm3 <- lm(log_pp ~ water_mass, data=syn)
anova(syn_lm1, syn_lm2)
anova(syn_lm2, syn_lm3)
plot(syn_lm3)
```
```{r}
Anova(syn_lm3, type = "3")
```
diagnostic tests for linear model fit
```{r}
par(mfrow = c(2, 2))
plot(syn_lm2)
```

# Pico
```{r}
pico <- rates_data %>%
  filter(population == "Pico") %>%
  mutate(log_pp = log10(pp))
```
First, I visualise the data without considering the random effects.
```{r}
ggplot(pico, aes(x=depth, y=pp)) +geom_boxplot() + geom_point()+scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") 
ggplot(pico, aes(x=depth, y=npp)) +geom_boxplot() + geom_point()+scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") 
ggplot(pico, aes(x=cycle_level, y=pp, colour = depth)) +geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") + geom_smooth(method = 'lm') 
```
## visualise raw data
data looks skewed. shapiro test  p= <0.01, data is not normally distributed. Need to log transform
```{r}
hist(pico$pp)
qqnorm(pico$pp) + qqline(pico$pp)
shapiro.test(pico$pp)

hist(pico$log_pp)
qqnorm(pico$log_pp) + qqline(pico$log_pp)
shapiro.test(pico$log_pp)

leveneTest(pico$log_pp, pico$depth)
```

```{r}
pico_lm1 <- lm(log_pp ~ depth*cycle_level, data=pico)
pico_lm2 <- lm(log_pp ~ depth+cycle_level, data=pico)

pico_lm3 <- lm(log_pp ~ cycle_level, data=pico)
anova(pico_lm1, pico_lm2)
anova(pico_lm2, pico_lm3)
```
```{r}
Anova(pico_lm3, type = "3")
summary(pico_lm3)
```

# Nano
```{r}
nano <- rates_data %>%
  filter(population == "Nano") %>%
  mutate(log_pp = log10(pp))
```

```{r}
ggplot(nano, aes(x=depth, y=pp)) +geom_boxplot() + geom_point()+scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") 
ggplot(nano, aes(x=depth, y=npp)) +geom_boxplot() + geom_point()+scale_y_continuous(trans='log10') + annotation_logticks(sides = "l")
ggplot(nano, aes(x=cycle_level, y=pp, colour = depth)) +geom_point() + scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") + geom_smooth (method = 'lm') 
```
## visualise raw data
data looks skewed. shapiro test  p= <0.01, data is not normally distributed. Need to log transform
```{r}
hist(nano$pp)
qqnorm(nano$pp) + qqline(nano$pp)
shapiro.test(nano$pp)

hist(nano$log_pp)
qqnorm(nano$log_pp) + qqline(nano$log_pp)
shapiro.test(nano$log_pp)

leveneTest(nano$log_pp, nano$depth)
```

```{r}
nano_lm1 <- lm(log_pp ~ depth*cycle_level, data=nano)
nano_lm2 <- lm(log_pp ~ depth+cycle_level, data=nano)

nano_lm3 <- lm(log_pp ~ cycle_level, data=nano)
anova(nano_lm1, nano_lm2)
anova(nano_lm2, nano_lm3)
```

```{r}
Anova(nano_lm3, type = "3")
summary(nano_lm3)
```
# GAM test

```{r}
library(mgcv)
gam_syn_m1 <- gam(log10(pp) ~ depth + s(cycle_level, k=5) , data = syn, method = "REML")
plot(gam_syn_m1)
summary(gam_syn_m1)
```

```{r}
gam_syn_m2 <- gam(log10(pp) ~s(cycle_level,k=5), data = syn, method = "REML")
plot(gam_syn_m2)
summary(gam_syn_m2)
variance_comp(gam_syn_m2)
par(mfrow = c(2, 2))
gam.check(gam_syn_m2)
AIC(gam_syn_m1, gam_syn_m2)
```

```{r}
gam_pico_m1 <- gam(log10(pp) ~ depth + s(cycle_level, k=5) , data = pico, method = "REML")
plot(gam_pico_m1)
summary(gam_pico_m1)
```

```{r}
gam_pico_m2 <- gam(log10(pp) ~s(cycle_level,k=5), data = pico, method = "REML")
plot(gam_pico_m2)
summary(gam_pico_m2)
variance_comp(gam_pico_m2)
par(mfrow = c(2, 2))
gam.check(gam_pico_m2)
AIC(gam_pico_m1, gam_pico_m2)
```

```{r}
gam_nano_m1 <- gam(pp ~ depth + s(cycle_level, k=5) , data = nano, method = "REML")
plot(gam_nano_m1)
summary(gam_nano_m1)
```

```{r}
gam_nano_m2 <- gam(pp ~s(cycle_level,k=5), data = nano, method = "REML")
plot(gam_nano_m2)
summary(gam_nano_m2)
variance_comp(gam_nano_m2)
par(mfrow = c(2, 2))
gam.check(gam_nano_m2)
AIC(gam_nano_m1, gam_nano_m2)
```