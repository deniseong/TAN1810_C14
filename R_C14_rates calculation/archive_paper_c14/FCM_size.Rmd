---
title: "FCM size analysis"
author: "Denise Ong"
date: "11/14/2022"
output: html_document
---

Data used for cell concentration is based on preserved samples for Pro and Syn, and live shipboard analysis for pico and nano euks. For euks, about 30% of the euks are lost when preserved.
Does preservation affect the size of the cell? Using all live values for size analysis for Syn, pico and nanoeuks first. May change to preserved for Syn to keep consistent

Looking at the live vs preserved cell diameters - better to use preserved. 

I am using MD_PhotoAdapt_Biomass_Rates_17MAR20.xlsx data, initial values only. 
U9133 (cycle 2, exp 5) has no counts - also for the NPP calculations. INitially I took the average of the counts. But maybe just exclude? Since cycle 2 has 4 experiments.

MD7: Pico is split into pico 1 and pico 2
MD8 does not have readings. U9128 for initials

# Initialise
```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(here)
source(here("init_files", "init.R")) #for libraries
source(here("init_files", "init_markdown.R")) #for markdown libraries

colours_cycle <- readxl::read_excel("init_files/colours_cycle.xlsx")
colours_cycle <- structure(colours_cycle$colour,.Names=colours_cycle$cycle)

colours_exp <- readxl::read_excel("init_files/colours_cycle.xlsx", sheet = "exp")
colours_exp <- structure(colours_exp$colour,.Names=colours_exp$exp)
```

# Read data
```{r, message=FALSE}
#use the "complete data TAN1810" sheet for the experiment number
C14_hot <- readxl::read_excel("data_used/TAN1810_14C-Pico_25052020_QA_1.2.xlsx", sheet = "Complete data TAN1810", skip = 11) %>%
  dplyr::select (`Cycle#`, `EXP#`, `CTD#`, `STN`, `SAMPLE`, `DEPTH`) %>%   
     dplyr::rename(cycle = `Cycle#`,
            exp = `EXP#`,
            CTD = `CTD#`,
            depth_cat = `SAMPLE`, 
            depth_m = `DEPTH`,
            station = `STN`)%>%
    distinct() %>%
  filter(!is.na(cycle))

# For live shipboard samples - syn, pico, nano
# match CTD number to MD number
md_meta <- readxl::read_excel("data_used/MD_PhotoAdapt_Biomass_Rates_17MAR20.xlsx", sheet = "Summary of PhotoAdaption ", skip = 3) %>% 
  select(Station, Cast, Cycle, MD) %>%
  rename(station = Station,
         CTD = Cast,
         cycle = Cycle) %>%
  distinct()

md_meta$CTD <- sub("^", "U", md_meta$CTD) # add U before CTD number

#loop to read all sheets except md1. missing MD8. Reading only initials for FSC of Syn, pico, nano
md_comb<- data.frame()
for (i in c(2:7, 9:18)) {
md <- readxl::read_excel("data_used/MD_PhotoAdapt_Biomass_Rates_17MAR20.xlsx", sheet = (str_c("MD", i)), skip = 2, n_max = 8) %>%
  select('Depth','SYN MEAN FS':'NANO MEAN FS') %>%
  mutate(MD = i) %>%
  rename(depth_m = 'Depth')
 md_comb <- bind_rows(md_comb, md)
}
md1 <- readxl::read_excel("data_used/MD_PhotoAdapt_Biomass_Rates_17MAR20.xlsx", sheet = "MD1", skip = 2, n_max = 8) %>%
  select('Depth...2','SYN MEAN FS':'NANO MEAN FS') %>%
  mutate(MD = 1) %>%
  rename(depth_m = 'Depth...2')

md_lv <- full_join(md_comb, md1) %>%
  arrange(MD) %>%
  full_join(md_meta, by = "MD") %>% # add cycle number
  rename(syn_LV = 'SYN MEAN FS',
         pico = 'PICO-E MEAN FS',
         pico1 = 'PICO1 MEAN FS',
         pico2 = 'PICO2 MEAN FS',
         nano = 'NANO MEAN FS') %>%
  mutate(pico = case_when(MD==7 ~(pico1+pico2)/2, #calculate mean for pico MD7
                              TRUE ~ pico)) 


# Preserved samples - only Syn
sv<- readxl::read_excel("data_used/MD SI SVFCM DATA ALL.xlsx", sheet = "ALL MD EOC SI", skip = 20, n_max = 683) %>%
  select('MD...2', 'DEPTH...4', 'SYN NORM FSC') %>%
  rename(MD = 'MD...2',
         depth_m = 'DEPTH...4',
         syn_SV = 'SYN NORM FSC') %>%
  filter(!(is.na(syn_SV))) %>%
  separate(MD, c("MD", "time", "CTD")) %>%
  filter(!(time %in% c("FINS", "FIN"))) %>%
  mutate(CTD = case_when(is.na(CTD) ~ time,
                         TRUE ~ CTD)) %>%
  select(-time) %>%
  group_by(MD,CTD, depth_m) %>%
  summarise(syn_SV = mean(syn_SV)) %>% # each depth has 3 readings. Take the average.
  ungroup() 

md_all <- md_lv %>%
  mutate(MD = str_c("MD", MD)) %>%
  full_join(sv) %>%
  full_join(C14_hot) %>%
  mutate(cycle =  case_when (MD == "EOC1" ~ 1, # fill in missing values
                             MD == "EOC2" ~ 2,
                             MD == "EOC3" ~ 4,
                             MD == "EOC4" ~ 4,
                             MD == "EOC5" ~ 5,
                             MD == "MD1" ~ 1,
                             MD == "MD12" ~ 3,
                             MD == "MD8" ~2,
                             TRUE ~ cycle)) %>%
  mutate(exp = case_when (CTD == "U9128" ~ 4,
                          TRUE ~ exp)) %>%
  mutate(cycle_name = recode(cycle, "1" = "SA1", # add cycle name
                                    "2" = "SA2",
                                    "3" = "ST1",
                                    "4" = "ST2",
                                    "5" = "SA3")) %>%
  mutate(water_mass = recode(cycle, "1" = "SA", # water mass assignment
                                    "2" = "SA",
                                    "3" = "ST",
                                    "4" = "ST",
                                    "5" = "SA")) %>%
  mutate(water_mass = fct_relevel(water_mass, "ST", "SA")) %>%
  mutate(depth_cat = case_when(depth_m == 12 ~ "SUR", # all surface exp are at 12 m
                               depth_m == 40 ~ "DCM", # assuming that cycles 1-4 DCM is at 40 m, although not accurate because cycle 3 one is at 25m and one is at 40 m. 
                               depth_m == 70 & cycle ==5 ~ "DCM",
                               TRUE ~ depth_cat)) %>% # assign depth levels for groups without
  mutate(depth_cat = fct_relevel(depth_cat, "SUR", "DCM")) %>%
  pivot_longer(cols = c("syn_LV":"nano", "syn_SV"), values_to = "fsc", names_to = "population") %>%
  filter(!(population == "syn_LV" & MD == "MD3")) %>% # remove this because FSC values after 5 m is 0 
  filter(MD != "EOC3") %>% # only 2 readings (5 m and 12 m)
  filter(!(population == "syn_LV" & MD == "MD13" & depth_m == 100)) %>% # skews the values by alot. Calculated cell diameter is 4um.
  filter(!(is.na(fsc))) %>%
  arrange(cycle, MD, population, depth_m) 
  
```

# FSC raw values
syn MD3 cycle 1, fsc values after 5m is 0 - Removed. 
Overall, fsc values at surface is higher than DCM. 
```{r}
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  md_select <-  md_all %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(fsc))) %>%
    filter(population ==i)
  p <-  md_all %>%
    filter(!(is.na(fsc))) %>%
    filter(population ==i) %>%
     ggplot(aes(x=fsc, y=depth_m)) +
      geom_path() +
      geom_point() +
    geom_point(data=md_select, aes(x=fsc, y=depth_m, color='red'),
               size=3)+
      scale_y_reverse() +
      facet_wrap(.~cycle_name + MD, nrow=4, scales = "free") +
  ggtitle(str_c("FSC raw - ", i)) +
    theme_minimal() +
    theme(legend.position = "none") 
 print(p)
pdf(here(str_c("figures/3_fcm/fsc_raw_", i, ".pdf")), height=8, width=8) ; plot(p) ; dev.off()

}
```

```{r, eval=FALSE}
# Make plots for all to check

for(i in c(1:7, 9:18)){
  p <-  md_all %>%
    filter(population =="syn_LV") %>%
    filter(MD==i) %>%
     ggplot(aes(x=fsc, y=depth_m)) +
     geom_path() +
    geom_point() +
  scale_y_reverse() +
    ggtitle(str_c("syn_LV",i))
print(p)
}

for(i in c(1:7, 9:18)){
  p <-  md_all %>%
    filter(MD==i) %>%
     ggplot(aes(x=pico_fsc, y=depth_m)) +
     geom_path() +
    geom_point() +
  scale_y_reverse() +
    ggtitle(str_c("Pico",i))
print(p)
}

for(i in c(1:7, 9:18)){
  p <-  md_all %>%
    filter(MD==i) %>%
     ggplot(aes(x=nano_fsc, y=depth_m)) +
     geom_path() +
    geom_point() +
  scale_y_reverse() +
    ggtitle(str_c("Nano",i))
print(p)
}


```

plot the mean and median fsc for each MD. Sometimes there are very large values skewing the reading so maybe median is better. Not sure if it is ok to plot median for each.
Using median - ST > SA for all, from boxplot looks like pico and nano are significantly higher. 

to plot everything - all have 5m to 100/150m. 8 depths measured. 
from boxplot - pico is
## all values
```{r}
# plot mean of each MD
p <- md_all %>%
  group_by(water_mass, cycle_name, MD, population) %>%
  summarise(mean = mean(fsc),
            median = median(fsc)) %>%
  ggplot() +
  geom_point(aes(x=cycle_name, y=median)) +
  geom_boxplot(aes(x=water_mass, y=median))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) 
p

# plot all values
p <- md_all %>%
  ggplot() +
  geom_jitter(aes(x=cycle_name, y=fsc), alpha = 0.3, width = 0.1) +
  geom_boxplot(aes(x=water_mass, y=fsc))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) +
  scale_y_continuous(trans='log10') +
    annotation_logticks(sides = "l")
p
```
## Summary statistics
```{r}
summary <- md_all %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(fsc, na.rm=TRUE),
            sd=sd(fsc, na.rm = TRUE),
            median=median(fsc, na.rm = TRUE),
            n=n())
summary
```
## Only surface and DCM
all groups decrease from ST to SA. 
for syn and pico, no difference in surface and DCM
but NANO sur>DCM. some sort of niche partitioning? There is a small difference in community composition but too few samples to make a comparison.
```{r}
p <- md_all %>%
  filter(!(is.na(depth_cat))) %>%
  filter(!(is.na(fsc))) %>%
  ggplot()+
  geom_jitter(aes(x=cycle_name, y=fsc), width = 0.2) +
  geom_boxplot(aes(x=water_mass, y=fsc))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) 
p

pdf("figures/3_fcm/fsc_surdcm_group.pdf", height=7, width=6) ; plot(p) ; dev.off()

# surface vs DCM
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  p <-  md_all %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(fsc))) %>%
    filter(population ==i) %>%
    ggplot() +
      geom_jitter(aes(x=cycle_name, y=fsc), width = 0.2) +
      geom_boxplot(aes(x=water_mass, y=fsc))+
      facet_grid(water_mass~depth_cat, scales = "free") +
     # facet_grid(depth_cat~water_mass, scales = "free") +
      scale_colour_manual(values = colours_cycle) +
    theme_minimal()+
    ggtitle(i)
  print(p)

}

summary <- summary <- md_all %>%
  filter(!(is.na(depth_cat))) %>%
  filter(!(is.na(fsc))) %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(fsc, na.rm=TRUE),
            sd=sd(fsc, na.rm = TRUE),
            median=median(fsc, na.rm = TRUE),
            n=n()) %>%
  as.integer()
summary
```

# Calculate cell diameter
calculations based on bead size.
diam = um
vol =um3
biomass = pgC/cell
```{r}
cell_size <- md_all %>%
  ungroup() %>%
  mutate(diam = case_when(population == "syn_LV" ~ (224333+fsc)/235871,
                          population == "pico" ~ (224333+fsc)/235871,
                          population == "nano" ~(224333+fsc)/235871,
                          population == "syn_SV" ~ (fsc+26.472)/31.028)) %>%
  mutate(vol = 4/3*3.14*(diam/2)^3) %>% #assuming spherical shape
  mutate(biomass = case_when(population == "pico" ~ (0.216*(vol^(0.939))),
                             population == "nano" ~ (0.216*(vol^(0.939))),
                             # population == "pico" ~ (10^(-0.665+log10(vol)*0.959)), # equation from Karen's excel sheets. Not sure why it is different from Menden paper.
                             # population == "nano" ~ (10^(-0.665+log10(vol)*0.959)),
                             population == "syn_LV" ~ vol*265/1000,
                             population == "syn_SV" ~ vol*265/1000)) 
# writexl::write_xlsx(cell_size, path = "group_rates_output/fsc_cell size.xlsx")
```

## Diameter
```{r}
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  cell_size_select <-  cell_size %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(diam))) %>%
    filter(population ==i)
  p <-  cell_size %>%
    filter(!(is.na(diam))) %>%
    filter(population ==i) %>%
     ggplot(aes(x=diam, y=depth_m)) +
      geom_path() +
      geom_point() +
    geom_point(data=cell_size_select, aes(x=diam, y=depth_m, color='red'),
               size=3)+
      scale_y_reverse() +
      facet_wrap(.~cycle_name + MD, nrow=4, scales = "free") +
  ggtitle(str_c("Cell diameter (um) - ",i)) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 90)) 
 print(p)
# pdf(here(str_c("figures/3_fcm/fsc_cell diameter_", i, ".pdf")), height=8, width=8) ; plot(p) ; dev.off()

}
```

### all values
```{r}
# plot mean of each MD
p <- cell_size %>%
  group_by(water_mass, cycle_name, MD, population) %>%
  summarise(mean = mean(diam),
            median = median(diam)) %>%
  ggplot() +
  geom_point(aes(x=cycle_name, y=median)) +
  geom_boxplot(aes(x=water_mass, y=median))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) 
p

# plot all values
p <- cell_size %>%
  ggplot() +
  geom_jitter(aes(x=cycle_name, y=diam), alpha = 0.3, width = 0.1) +
  geom_boxplot(aes(x=water_mass, y=diam))+
  facet_grid(population~water_mass, scales = "free") 
p
```

### Summary statistics
```{r}
summary <- cell_size %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(diam, na.rm=TRUE),
            sd=sd(diam, na.rm = TRUE),
            median=median(diam, na.rm = TRUE))
summary
```
### Only surface and DCM
all groups decrease from ST to SA. 
for syn and pico, no difference in surface and DCM
but NANO sur>DCM. some sort of niche partitioning? There is a small difference in 
```{r}
theme_set(theme_bw())
p <- cell_size %>%
  filter(!(is.na(depth_cat))) %>%
  filter(!(is.na(diam))) %>%
  ggplot()+
  geom_jitter(aes(x=cycle_name, y=diam), width = 0.2) +
  geom_boxplot(aes(x=water_mass, y=diam))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) 
p
# pdf("figures/3_fcm/diam_surdcm_group.pdf", height=7, width=6) ; plot(p) ; dev.off()

# surface vs DCM
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  p <-  cell_size %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(diam))) %>%
    filter(population ==i) %>%
    ggplot() +
      geom_jitter(aes(x=cycle_name, y=diam), width = 0.2) +
      geom_boxplot(aes(x=water_mass, y=diam))+
      facet_grid(water_mass~depth_cat, scales = "free") +
      scale_colour_manual(values = colours_cycle) +
    ggtitle(i)
  print(p)
# pdf(here(str_c("figures/3_fcm/diam_sur dcm_", i, ".pdf")), height=4, width=6) ; plot(p) ; dev.off()

}
```

## Diameter - statistical test
### Kruskal wallis test (for comparing syn, pico, nano)
```{r}
stats_rates <- cell_size %>%
  filter(population !="syn_SV") %>%
  filter(!(is.na(depth_cat)))
hist(stats_rates$diam)
qqnorm(stats_rates$diam) 
shapiro.test(stats_rates$diam)

hist(log10(stats_rates$diam))
qqnorm(log10(stats_rates$diam))
shapiro.test(log10(stats_rates$diam))
# all not normal. Use kruskal wallis test.

kruskal.test(diam~population, data = stats_rates) #significant. followed by dunn pairwise test
pairwise.wilcox.test(stats_rates$diam, stats_rates$population,
                     p.adjust.method = "BH")


```
### t test to check if surface is different from DCM
surface is not different from DCM for syn and pico. for nano sur > dcm
```{r}
library("ggpubr")

for (i in c("syn_LV", "pico", "nano")) {
t_test_df<- stats_rates %>%
  filter(population == i) %>%
  select(water_mass,exp, depth_cat, diam) %>%
  distinct()

summary <- t_test_df %>%
  group_by(depth_cat) %>%
  summarise(count = n(),
    mean = mean(diam, na.rm = TRUE),
    sd = sd(diam, na.rm = TRUE))
print(summary)
 p <- t_test_df %>%
   ggplot(aes(x=depth_cat, y=diam)) + 
   geom_point() +
   geom_boxplot()  
 print(p)

#Because p value <0.05, data is not normally distributed. Use the wilcoxon test
p<-with(t_test_df, shapiro.test(diam[depth_cat == "SUR"]))
print(p)
p<-with(t_test_df, shapiro.test(diam[depth_cat == "DCM"]))
print(p)
res <- wilcox.test(diam ~ depth_cat, data = t_test_df,
                   exact = FALSE)
print(res)
}
```

### t test - ST vs SA
```{r}
library("ggpubr")

for (i in c("syn_LV", "pico", "nano")) {
t_test_df<- stats_rates %>%
  filter(population == i) %>%
  select(water_mass, exp, depth_cat, diam)

summary <- t_test_df %>%
  group_by(water_mass) %>%
  summarise(count = n(),
    mean = mean(diam, na.rm = TRUE),
    sd = sd(diam, na.rm = TRUE))
print(summary)
 p <- t_test_df %>%
   ggplot(aes(x=water_mass, y=diam)) + geom_point() +geom_boxplot()  
 print(p)

#Because p value <0.05, data is not normally distributed. Use the wilcoxon test
p<-with(t_test_df, shapiro.test(diam[water_mass == "ST"]))
print(p)
p<-with(t_test_df, shapiro.test(diam[water_mass == "SA"]))
print(p)
res <- wilcox.test(diam ~ water_mass, data = t_test_df,
                   exact = FALSE)
print(res)
}
```
## Biomass
```{r}
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  cell_size_select <-  cell_size %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(biomass))) %>%
    filter(population ==i)
  p <-  cell_size %>%
    filter(!(is.na(biomass))) %>%
    filter(population ==i) %>%
     ggplot(aes(x=biomass, y=depth_m)) +
      geom_path() +
      geom_point() +
    geom_point(data=cell_size_select, aes(x=biomass, y=depth_m, color='red'),
               size=3)+
      scale_y_reverse() +
      facet_wrap(.~cycle_name + MD, nrow=4, scales = "free") +
  ggtitle(str_c("Cell biomass (pgC/cell) - ",i)) +
    theme_minimal() +
    theme(legend.position = "none",
          axis.text.x = element_text(angle = 90)) 
 print(p)
#pdf(here(str_c("figures/3_fcm/fsc_cell biomass_", i, ".pdf")), height=8, width=8) ; plot(p) ; dev.off()

}
```

### all values
```{r}
# plot mean of each MD
p <- cell_size %>%
  group_by(water_mass, cycle_name, MD, population) %>%
  summarise(mean = mean(biomass),
            median = median(biomass)) %>%
  ggplot() +
  geom_point(aes(x=cycle_name, y=median)) +
  geom_boxplot(aes(x=water_mass, y=median))+
  facet_grid(population~water_mass, scales = "free") +
  scale_colour_manual(values = colours_cycle) 
p

# plot all values
p <- cell_size %>%
  mutate(biomass_fg = 1000*biomass) %>%
  ggplot() +
  geom_jitter(aes(x=cycle_name, y=biomass_fg), alpha = 0.3, width = 0.1) +
  geom_boxplot(aes(x=water_mass, y=biomass_fg))+
  scale_y_continuous(trans='log10') + annotation_logticks(sides = "l") +
  facet_grid(population~water_mass, scales = "free") 
p
pdf("figures/3_fcm/biomass_all_group.pdf", height=7, width=6) ; plot(p) ; dev.off()

```

### Summary statistics
```{r}
summary <- cell_size %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(biomass *1000, na.rm=TRUE),
            sd=sd(biomass *1000, na.rm = TRUE),
            median=median(biomass, na.rm = TRUE))
summary
```

### Only surface and DCM
all groups decrease from ST to SA. 
for syn and pico, no difference in surface and DCM
but NANO sur>DCM. some sort of niche partitioning? There is a small difference in 
```{r}
p <- cell_size %>%
  filter(!(is.na(depth_cat))) %>%
  filter(!(is.na(biomass))) %>%
  mutate(biomass_fg = 1000*biomass) %>%
  ggplot()+
  geom_jitter(aes(x=cycle_name, y=biomass_fg), width = 0.2) +
  geom_boxplot(aes(x=population, y=biomass_fg)) +
  facet_grid(.~population, scales = "free") +
  scale_y_continuous(trans='log10') +
  annotation_logticks(sides = "l")
p

p <- cell_size %>%
  filter(!(is.na(depth_cat))) %>%
  filter(!(is.na(biomass))) %>%
    mutate(biomass_fg = 1000*biomass) %>%
  ggplot()+
  geom_jitter(aes(x=cycle_name, y=biomass_fg), width = 0.2) +
  geom_boxplot(aes(x=water_mass, y=biomass_fg))+
  facet_grid(population~water_mass, scales = "free") 
# +
  # scale_colour_manual(values = colours_cycle) +
  # scale_y_continuous(trans='log10') +
  # annotation_logticks(sides = "l")
p

# pdf("figures/3_fcm/biomass_surdcm_group.pdf", height=7, width=6) ; plot(p) ; dev.off()


# surface vs DCM
for(i in c("syn_SV", "syn_LV", "pico", "nano")){
  p <-  cell_size %>%
    filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(biomass))) %>%
      mutate(biomass_fg = 1000*biomass) %>%
    filter(population ==i) %>%
    ggplot() +
      geom_jitter(aes(x=cycle_name, y=biomass_fg), width = 0.2) +
      geom_boxplot(aes(x=water_mass, y=biomass_fg))+
      facet_grid(.~depth_cat, scales = "free") +
      scale_colour_manual(values = colours_cycle) +
    ggtitle(i)
  print(p)

}

summary <- cell_size %>%
  filter(!(is.na(depth_cat))) %>%
    filter(!(is.na(biomass))) %>%
  mutate(biomass_fg = 1000*biomass) %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(biomass_fg, na.rm=TRUE),
            sd=sd(biomass_fg, na.rm = TRUE)) %>%
  pivot_wider(names_from = water_mass, values_from = mean)
summary
writexl::write_xlsx(summary, "biomass_summary.xlsx")
```

```{r}
summary <- cell_size %>%
  group_by(population, water_mass) %>%
  summarise(mean=mean(biomass, na.rm=TRUE),
            sd=sd(biomass, na.rm = TRUE),
            median=median(biomass, na.rm = TRUE))
summary
```

