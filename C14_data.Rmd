---
title: "C14"
author: "Denise Ong"
date: "4/2/2020"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE,
                        tidy = FALSE)
```

# Denise edits on 19 April 2020

```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
library(broom)
```

## Read C14 data
```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%
  dplyr::select (Cycle, EXP, STN, DEPTH, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1, `SA in DPM (aproximation)`) %>%   
  # Can add more variables latter
  # station and depth for adding updated DIC values
     rename(cycle = Cycle,
            exp = EXP, 
            station = STN,
            depth = DEPTH,
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1,
            SA = `SA in DPM (aproximation)`) %>%
    filter(population != "Nano")

C14_DPM
```

## Substract the dark DPM
Join tables based on common variables

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  dplyr::select(-vial) # Remove the vial column
C14_DPM_Dark
# Check the values of dpm dark with histogram. The values are normally distributed, concentrated around the mean.
hist(C14_DPM_Dark$dpm_dark)
mean(C14_DPM_Dark$dpm_dark)
```


```{r}
C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  # DV - The next line sets dpm_dark to average dpm_dark if no value. Checked with histogram above.
  mutate(dpm_dark = case_when (is.na(dpm_dark) ~ mean(dpm_dark, na.rm = TRUE),
                               TRUE ~ dpm_dark))  %>% 
  # DV - The next line set dpm_correct to zero if negative, as negative values are all close to zero.
  mutate(dpm_corrected = case_when (dpm >= dpm_dark ~ dpm - dpm_dark,
                                    TRUE ~0)) %>% 
  filter(!(exp == 2 & sample == "DCM" & vial == "A")) %>% # I removed this row as there was only one value for the population in the vial.
  filter(!(exp == 6 & sample == 'SUR' & vial == 'C' & population == 'Pico' & cells_sorted == 2000)) %>% # This value is too high
  filter(!(exp == 6 & sample == 'SUR' & vial == 'C' & population == 'Syn' & cells_sorted == 2000)) # This value is too high
C14_DPM_corrected  
  
```

## Method 2 - Compute lm for  ABC separately

### Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r fig.height=15, fig.width=10}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  # DV - Set the y_scale to free so that graph is more easy to read
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
```



### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_3 <- C14_DPM_corrected %>%
  group_by(cycle, exp, station, depth, sample, population, vial, SA) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_3 <- C14_DPM_model_3 %>% 
  dplyr::select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_3
  
```


## Include DIC

Import DIC data from Andres. I will use this data to join with the DPM model output. The corrected data frame will have the DIC. The data will join based on the common columns: station and depth. 

### Create DIC table
```{r}

# DV - Read the help for Excel you can choose the number of rows to skip and use select rather than base R
DIC_data <- readxl::read_excel("Chla NPP Raw TAN1810 Sept.xlsx", sheet = "Compiled TAN1810 NPP data", skip = 5) %>% 
  select(c(1:34), -c(1,27))

# select for station, depth, DIC, SA. Change all columns to integer to join with DPM output.
DIC_data_corrected <- select(DIC_data, Station, `Depth m`, DIC) %>%
  unique() %>% # delete repeated rows
  rename(station = Station,
         depth = `Depth m`) %>%
  filter(depth != "35/40?") %>% # filter out character to change to integer
  mutate_if(is.character, as.double) # change to double (same format as DPM dataset)

DIC_data_corrected
```


### Merge DIC/SA table and DPM output
```{r}
# merge tables
pp_cal <- left_join(C14_DPM_model_output_3, DIC_data_corrected)
pp_cal
```

# Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
pp_cal <- mutate(pp_cal, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%
  select( -c(station, depth)) %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal <- complete(pp_cal, nesting(cycle, exp, sample), vial, population) 
  
pp_cal
```


Compute means quickly.

```{r}
 
pp_cal %>% 
  group_by(population, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE))

pp_cal %>% 
  ggplot() +
  geom_point(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")

pp_cal %>% 
  ggplot() +
  geom_boxplot(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")
```

The units for pp is fgC/h/cell.
Rii (2016) finds 5â€“11 fmol C/cell/day for Syn  need to convert from fmol C to fg C and from hours to day... to compare

\pagebreak

# Daniel solution

A few things:

* Please read in detail R for data science chapter on grouping data: https://r4ds.had.co.nz/transform.html
* Please read in detail R for data science chpater on joining data:  https://r4ds.had.co.nz/relational-data.html
* You can also go back to my class here: https://vaulot.github.io/course-ntu-data-science-2020/R-session-04-data_wrangling.html
* When you group data you must explicty tell which operation you want to perform (e.g. n() for counting, sum(), mean ()). If not no need to group data
* Make your code general from the start so that to extend to all cases, no need to rewrite it.  
* It is much better to rename immediately your varibales in a clean way

## Read the data

```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%  # Explicit name and not position
     select ( EXP, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1) %>%   # Can add more variables latter
     rename(exp = EXP, 
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1) %>% 
     filter(exp == 1)  # You will just need to remove this line to make the code valid for all experiments
C14_DPM
```


## Substract the dark DPM

You need to make join based on the common variables 

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  select(-vial) # Remove the vial column
C14_DPM_Dark


C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  mutate(dpm_corrected = dpm - dpm_dark) %>% 
  filter(dpm_corrected >= 0) # Remove negative values
  
C14_DPM_corrected  
  
```

## Method 1 - Compute lm by grouping ABC together

### Plots

Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population)) +
  geom_point() + stat_smooth(method="lm") +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_1 <- C14_DPM_corrected %>%
  group_by(exp, sample, population) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_1 <- C14_DPM_model_1 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_1
  
```

## Method 2 - Compute lm for  ABC separately

### Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_2 <- C14_DPM_corrected %>%
  group_by(exp, sample, population, vial) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_2 <- C14_DPM_model_2 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_2
  
```



### Some notes from 14 April:
- For the purposes of Eleanor's class, I will use method 2 (compute lm values for ABC separately) for more replicates, but method 1 will be used for actual calculations later.
- No need to check p value of the slope.
- Will not set intercept to 0.

