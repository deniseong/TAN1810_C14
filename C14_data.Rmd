---
title: "C14"
author: "Denise Ong"
date: "4/2/2020"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE,
                        tidy = FALSE)
```

# Load data
```{r}
C14 <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = 2)
C14$EXP <- as.character(C14$EXP)
C14
```

# Load libraries, and narrow down the columns for the dataset.
```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
# create a new dataset
C14_1 <- select(C14, julian_day, Cycle, STN, EXP, SAMPLE, Lat_DD, Long_DD, DEPTH, 'Vial code', 'sorting population', 'Cells sorted', DPM1)
#C14_1
```

To include only essential columns. Can edit code to include other columns that are essential later.
```{r}
# Tidy for essential columns
C14_DPM <- C14_1 %>%
  select ( EXP, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1)
#C14_DPM
```

# First, I focused on experiment 1 only to try 2 different methods I had in mind.
```{r}
#filter for exp 1
C14_E1 <- filter(C14_DPM, EXP==1)
#C14_E1
```

To make calculations easier, I first created a new dataset that would bring vial D to a new column called DPM_dark. I then create another column DPM2 = light - dark. DPM2 would be DPM data that I will use to calculate my PP.

# Problem: this method only works for complete dataset, and I would need to repeat for every experiment and depth. How do I set conditions to make sure that DPM_dark moves to its corresponding population? I would like to have a code that will apply to the entire dataset, without needed to subset the data.
```{r}
# create new column for D, repeating from A to C
# select values for DPM dark
subset1 <- subset(C14_E1, `Vial code` == "D",  select = c("DPM1"))
#subset1
# select for vials A to C
C14_E1 <- filter(C14_E1, `Vial code` != "D")
# create DPM dark column
C14_E1 <- mutate(C14_E1, DPM_dark = rep(subset1$DPM1, 3))
# DPMD2 = DPM light - dark
C14_E1 <- mutate(C14_E1, DPM2 = DPM1 - DPM_dark)

#C14_E1
```

# IGNORE Method 1: Calculate coefficient when vials A to C combined (I have decided not to use this method as it reduces my number of replicates)
```{r}
E1 <- C14_E1 %>%
  group_by(`sorting population`, `Cells sorted`, `Vial code`) %>%
  summarise(DPM2)
#E1
```


```{r}
E1_nano <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Nano")
E1_plot_nano <- ggplot(E1_nano, aes(x = `Cells sorted`, y = DPM2)) + geom_point()
#E1_plot_nano
```

```{r}
E1_pico <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Pico")
E1_plot_pico <- ggplot(E1_pico, aes(x = `Cells sorted`, y = DPM2)) + geom_point() + geom_smooth(method = lm)
#E1_plot_pico
E1_model_pico <- lm(DPM2 ~ `Cells sorted`, data=E1_pico)
#E1_model_pico
#summary(E1_model_pico)
```

```{r}
E1_syn <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Syn")
E1_plot_syn <- ggplot(E1_syn, aes(x = `Cells sorted`, y = DPM2)) + geom_point() + geom_smooth(method = lm)
#E1_plot_syn
E1_model_syn <- lm(DPM2 ~ `Cells sorted`, data=E1_syn)
#E1_model_syn
#summary(E1_model_syn)
```

# Method 2: calculate regression coefficient for each vial
This method is the one that I would like to use. The idea that I have is to group the data by sorting population (nano, pico, syn) and then by vial code. I would like to use a map function to create a new column that creates an LM function for each sorting population and vial, such that lm(DPM2~cells sorted), and then corresponding columns for the slope, p-value or each LM.  
# Problem: I took some examples online to try and fit to my data but the code doesnt work.
```{r}
library(dplyr)
library(broom)
library(tsibble)
```

```{r, eval=FALSE}
# This is the code example that I used. The link is https://community.rstudio.com/t/how-to-calculate-slope-with-conditions-in-r/36053.
df %>% 
    group_nest(Source.Name, visbility, soundvolume) %>% 
    mutate(model = map(data, ~lm(m ~ stim_ending_t, data = .x))) %>% 
    mutate(slope = map_dbl(model, ~tidy(.x)$estimate[2]))
```

```{r, eval=FALSE}
C14_E1_ts <- as.tibble(C14_E1)
#C14_E1_ts
E1_trial <- C14_E1_ts %>% 
  ungroup() %>%
  group_by(`sorting population`, `Vial code`)  %>%
  mutate(model = map(data, ~lm(DPM2~`Cells sorted`, data = .))) %>%
  mutate(slope = map_dbl(model, ~tidy(.)$estimate[2]))
#E1_trial
```

\pagebreak

# Daniel solution

A few things:

* Please read in detail R for data science chapter on grouping data: https://r4ds.had.co.nz/transform.html
* Please read in detail R for data science chpater on joining data:  https://r4ds.had.co.nz/relational-data.html
* You can also go back to my class here: https://vaulot.github.io/course-ntu-data-science-2020/R-session-04-data_wrangling.html
* When you group data you must explicty tell which operation you want to perform (e.g. n() for counting, sum(), mean ()). If not no need to group data
* Make your code general from the start so that to extend to all cases, no need to rewrite it.  
* It is much better to rename immediately your varibales in a clean way

## Read the data

```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%  # Explicit name and not position
     select ( EXP, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1) %>%   # Can add more variables latter
     rename(exp = EXP, 
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1) %>% 
     filter(exp == 1)  # You will just need to remove this line to make the code valid for all experiments
C14_DPM
```


## Substract the dark DPM

You need to make join based on the common variables 

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  select(-vial) # Remove the vial column
C14_DPM_Dark


C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  mutate(dpm_corrected = dpm - dpm_dark) %>% 
  filter(dpm_corrected >= 0) # Remove negative values
  
C14_DPM_corrected  
  
```

## Method 1 - Compute lm by grouping ABC together

### Plots

Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population)) +
  geom_point() + stat_smooth(method="lm") +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_1 <- C14_DPM_corrected %>%
  group_by(exp, sample, population) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_1 <- C14_DPM_model_1 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_1
  
```

## Method 2 - Compute lm for  ABC separately

### Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_2 <- C14_DPM_corrected %>%
  group_by(exp, sample, population, vial) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_2 <- C14_DPM_model_2 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_2
  
```

\pagebreak

# Denise edits

I made some additional changes. I filtered out Nano population, so the data will only have Pico and Syn. I also removed the filter for experiment 1, so the code is the entire dataset. I only used method 2 (compute lm for ABC separately). This set of edits will continue until the computation of PP as I have added the DIC and SA values from Andres, joining tables based on station no and depth (m). 

# Problems:
- From experiment 6: SUR: vial C: pico: 2000 cells sorted -> corrected DPM value = 1485, much higher than DPM of 4000 and 10000 cells counted.
- What should I do with negative slope values that result in negative pp values?

## Read the data

```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
library(broom)
library(tsibble)
```


```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%  # Explicit name and not position
     select ( Cycle, EXP, STN, DEPTH, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1) %>%   
  # Can add more variables latter
  # station and depth for adding updated DIC values
     rename(cycle = Cycle,
            exp = EXP, 
            station = STN,
            depth = DEPTH,
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1) %>%
    filter(population != "Nano")

C14_DPM
```


## Substract the dark DPM

You need to make join based on the common variables 

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  select(-vial) # Remove the vial column
C14_DPM_Dark
```

```{r}
C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  # DV - The next line sets dpm_dark to average dpm_dark if no value
  mutate(dpm_dark = case_when (is.na(dpm_dark) ~ mean(dpm_dark, na.rm = TRUE),
                               TRUE ~ dpm_dark))  %>% 
  # DV - The next line set dpm_correct to zero if negative
  mutate(dpm_corrected = case_when (dpm >= dpm_dark ~ dpm - dpm_dark,
                                    TRUE ~0)) %>% 
  filter(!(exp == 2 & sample == "DCM" & vial == "A")) # I removed this row as there was only one value for the population in the vial.
  
C14_DPM_corrected  
  
```

## Method 2 - Compute lm for  ABC separately

### Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r fig.height=15, fig.width=10}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  # DV - Set the y_scale to free so that graph is more easy to read
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
```

# need to check exp 6: SUR: Pico: C: 2000 cells sorted. Value is too high. Slope value is negative.

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_3 <- C14_DPM_corrected %>%
  group_by(cycle, exp, station, depth, sample, population, vial) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_3 <- C14_DPM_model_3 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_3
  
```

## Include DIC and SA values

Import DIC data from Andres. I will use this data to join with the DPM model output. The corrected data frame will have the DIC and SA values. The data will join based on the common columns: station and depth. 

### Create DIC table
```{r}

# DV - Read the help for Excel you can choose the number of rows to skip and use select rather than base R
DIC_data <- readxl::read_excel("Chla NPP Raw TAN1810 Sept.xlsx", sheet = "Compiled TAN1810 NPP data", skip = 5) %>% 
  select(c(1:34), -c(1,27))

# DV - The code below is replaced by line above

# excel sheet not optimal for R, have to delete columns and make row 5 headers.
# names(DIC_data) <- DIC_data[5,] # make row 5 header
# DIC_data <- DIC_data [-c(1, 2, 3, 4, 5), c(1:34)] 
# DIC_data <- DIC_data [, -c(1, 27)] # remove repeated columns
colnames(DIC_data) # check 

# select for station, depth, DIC, SA. Change all columns to integer to join with DPM output.
DIC_data_corrected <- select(DIC_data, Station, `Depth m`, DIC, SA) %>%
  unique() %>% # delete repeated rows
  rename(station = Station,
         depth = `Depth m`) %>%
  filter(depth != "35/40?") %>% # filter out character to change to integer
  mutate_if(is.character, as.double) # change to double (same format as DPM dataset)

DIC_data_corrected
```

### Merge DIC/SA table and DPM output
```{r}
# merge tables
# DV - Bad habit to call an objet final... nothing is really ever final
final_cal <- left_join(C14_DPM_model_output_3, DIC_data_corrected)
final_cal
```

# Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
final_cal <- mutate(final_cal, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%  # DV - Why are using ungroup here ?
  select( -c(station, depth))
#add missing rows for data analysis later
final_cal <- complete(final_cal, nesting(cycle, exp, sample), vial, population) 

final_cal
```

Compute means quickly

```{r}
 
final_cal %>% 
  group_by(population, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE))
```

Rii (2016) finds 5–11 fmol C/cell/day for Syn  need to convert from fmol C to fg C and from hours to day... to compare

### Some notes from 14 April:
- For the purposes of Eleanor's class, I will use method 2 (compute lm values for ABC separately) for more replicates, but method 1 will be used for actual calculations later.
- No need to check p value of the slope.
- Will not set intercept to 0.