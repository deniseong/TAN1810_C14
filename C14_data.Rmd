---
title: "C14"
author: "Denise Ong"
date: "4/2/2020"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE,
                        tidy = FALSE)
```

# Denise edits on 30 April 2020

The code for method 1 (Compute lm by grouping ABC together) and method 2 (Compute lm for  ABC separately) is completed. The last steps are removing values that are unusual.

```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
library(broom)
```

# 1. Read C14 data
```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%
  dplyr::select (Cycle, EXP, STN, DEPTH, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1, `SA in DPM (aproximation)`) %>%   
  # Can add more variables latter
  # station and depth for adding updated DIC values
     rename(cycle = Cycle,
            exp = EXP, 
            station = STN,
            depth = DEPTH,
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1,
            SA = `SA in DPM (aproximation)`) %>%
    filter(population != "Nano")

C14_DPM
```

## Substract the dark DPM
Join tables based on common variables

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  dplyr::select(-vial) # Remove the vial column
C14_DPM_Dark
# Check the values of dpm dark with histogram. The values are normally distributed, concentrated around the mean.
hist(C14_DPM_Dark$dpm_dark)
mean(C14_DPM_Dark$dpm_dark)
```

```{r}
C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  # DV - The next line replace dpm_dark to average dpm_dark if no value. Checked with histogram above.
  mutate(dpm_dark = case_when (is.na(dpm_dark) ~ mean(dpm_dark, na.rm = TRUE),
                               TRUE ~ dpm_dark))  %>% 
  # DV - The next line set dpm_correct to zero if negative, as negative values are all close to zero.
  mutate(dpm_corrected = case_when (dpm >= dpm_dark ~ dpm - dpm_dark,
                                    TRUE ~0)) %>% 
  filter(!(exp == 2 & sample == "DCM" & vial == "A")) %>% # I removed this row as there was only one value for the population in the vial.
  filter(!(exp == 6 & sample == 'SUR' & vial == 'C' & population == 'Pico' & cells_sorted == 2000)) %>% # This value is too high
  filter(!(exp == 6 & sample == 'SUR' & vial == 'C' & population == 'Syn' & cells_sorted == 2000)) # This value is too high
C14_DPM_corrected  
  
```


# 2. Include DIC

Import DIC data from Andres. I will use this data to join with the DPM model output. The corrected data frame will have the DIC. The data will join based on the common columns: station and depth. 

## Create DIC table
```{r}
DIC_data <- readxl::read_excel("Chla NPP Raw TAN1810 Sept.xlsx", sheet = "Compiled TAN1810 NPP data", skip = 5) %>% 
  select(c(1:34), -c(1,27))

# select for station, depth, DIC, SA. Change all columns to integer to join with DPM output.
DIC_data_corrected <- select(DIC_data, Station, `Depth m`, DIC) %>%
  unique() %>% # delete repeated rows
  rename(station = Station,
         depth = `Depth m`) %>%
  filter(depth != "35/40?") %>% # filter out character to change to integer
  mutate_if(is.character, as.double) # change to double (same format as DPM dataset)

DIC_data_corrected
```

# 3. Compute based on Method 1 - Compute lm by grouping ABC together

## Plots

Do plots for each group. One regression line based on the EXP, Sample and Populations
```{r fig.height=15, fig.width=10}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
```

## Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_1 <- C14_DPM_corrected %>%
  group_by(SA, cycle, exp, station, depth, sample, population) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_1 <- C14_DPM_model_1 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_1
  
```

## Merge DIC/SA table and DPM output
```{r}
# merge tables
pp_cal_1 <- left_join(C14_DPM_model_output_1, DIC_data_corrected)
pp_cal_1
```

## Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
pp_cal_1 <- mutate(pp_cal_1, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%
  select( -c(station, depth)) %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal_1 <- complete(pp_cal_1, nesting(cycle, exp, sample), population) 
  
pp_cal_1
```

```{r}
 
pp_cal_1 %>% 
  group_by(population, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE))

pp_cal_1 %>% 
  ggplot() +
  geom_point(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")

pp_cal_1 %>% 
  ggplot() +
  geom_boxplot(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")
```

# 4. Compute based on Method 2 - Compute lm for  ABC separately

## Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r fig.height=15, fig.width=10}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  # DV - Set the y_scale to free so that graph is more easy to read
  facet_grid(rows=vars(exp), cols=vars(sample), scales = "free_y") +
  scale_color_viridis_d()
```



## Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_2 <- C14_DPM_corrected %>%
  group_by(cycle, exp, station, depth, sample, population, vial, SA) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_2 <- C14_DPM_model_2 %>% 
  dplyr::select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (slope = cells_sorted, intercept = `(Intercept)`)

C14_DPM_model_output_2
  
```


## Merge DIC/SA table and DPM output
```{r}
# merge tables
pp_cal_2 <- left_join(C14_DPM_model_output_2, DIC_data_corrected)
pp_cal_2
```

## Calculate PP value, based on Daniel's formula found here:  
https://vaulot.netlify.com/2018/05/20/compute-primary-production-based-on-single-cell-c14-uptake/

```{r}
pp_cal_2 <- mutate(pp_cal_2, pp = DIC*slope*(1/(SA*24))*10^9*1.05) %>%
  ungroup() %>%
  select( -c(station, depth)) %>%
  filter(pp >= 0) # remove negative pp values

# add missing rows for data analysis later
pp_cal_2 <- complete(pp_cal_2, nesting(cycle, exp, sample), vial, population) 
  
pp_cal_2
```


Compute means quickly.

```{r}
 
pp_cal_2 %>% 
  group_by(population, sample) %>% 
  summarise(pp_mean = mean(pp, na.rm = TRUE))

pp_cal_2 %>% 
  ggplot() +
  geom_point(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")

pp_cal_2 %>% 
  ggplot() +
  geom_boxplot(aes(x= str_c(population,sample,  sep=" "), y = pp)) +
  xlab("Sample")
```

The units for pp is fgC/h/cell.
Rii (2016) finds 5â€“11 fmol C/cell/day for Syn which corresponds to 60-132 fg /day/cell ie 2.5 to 5.5 fg/h/cell.
