---
title: "C14"
author: "Denise Ong"
date: "4/2/2020"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(message=FALSE,
                        warning=FALSE,
                        cache=TRUE)
```

# Load data
```{r}
C14 <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = 2)
C14$EXP <- as.character(C14$EXP)
C14
```

# Load libraries, and narrow down the columns for the dataset.
```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
# create a new dataset
C14_1 <- select(C14, julian_day, Cycle, STN, EXP, SAMPLE, Lat_DD, Long_DD, DEPTH, 'Vial code', 'sorting population', 'Cells sorted', DPM1)
C14_1
```

To include only essential columns. Can edit code to include other columns that are essential later.
```{r}
# Tidy for essential columns
C14_DPM <- C14_1 %>%
  select ( EXP, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1)
C14_DPM
```

#First, I focused on experiment 1 only to try 2 different methods I had in mind.
```{r}
#filter for exp 1
C14_E1 <- filter(C14_DPM, EXP==1)
C14_E1
```

To make calculations easier, I first created a new dataset that would bring vial D to a new column called DPM_dark. I then create another column DPM2 = light - dark. DPM2 would be DPM data that I will use to calculate my PP.

# Problem: this method only works for complete dataset, and I would need to repeat for every experiment and depth. How do I set conditions to make sure that DPM_dark moves to its corresponding population? I would like to have a code that will apply to the entire dataset, without needed to subset the data.
```{r}
# create new column for D, repeating from A to C
# select values for DPM dark
subset1 <- subset(C14_E1, `Vial code` == "D",  select = c("DPM1"))
subset1
# select for vials A to C
C14_E1 <- filter(C14_E1, `Vial code` != "D")
# create DPM dark column
C14_E1 <- mutate(C14_E1, DPM_dark = rep(subset1$DPM1, 3))
# DPMD2 = DPM light - dark
C14_E1 <- mutate(C14_E1, DPM2 = DPM1 - DPM_dark)
C14_E1
```

# IGNORE Method 1: Calculate coefficient when vials A to C combined (I have decided not to use this method as it reduces my number of replicates)
```{r}
E1 <- C14_E1 %>%
  group_by(`sorting population`, `Cells sorted`, `Vial code`) %>%
  summarise(DPM2)
E1
```


```{r}
E1_nano <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Nano")
E1_plot_nano <- ggplot(E1_nano, aes(x = `Cells sorted`, y = DPM2)) + geom_point()
E1_plot_nano
```

```{r}
E1_pico <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Pico")
E1_plot_pico <- ggplot(E1_pico, aes(x = `Cells sorted`, y = DPM2)) + geom_point() + geom_smooth(method = lm)
E1_plot_pico
E1_model_pico <- lm(DPM2 ~ `Cells sorted`, data=E1_pico)
E1_model_pico
summary(E1_model_pico)
```

```{r}
E1_syn <- E1 %>% 
  ungroup() %>%
  filter(`sorting population` == "Syn")
E1_plot_syn <- ggplot(E1_syn, aes(x = `Cells sorted`, y = DPM2)) + geom_point() + geom_smooth(method = lm)
E1_plot_syn
E1_model_syn <- lm(DPM2 ~ `Cells sorted`, data=E1_syn)
E1_model_syn
summary(E1_model_syn)
```

# Method 2: calculate regression coefficient for each vial
This method is the one that I would like to use. The idea that I have is to group the data by sorting population (nano, pico, syn) and then by vial code. I would like to use a map function to create a new column that creates an LM function for each sorting population and vial, such that lm(DPM2~cells sorted), and then corresponding columns for the slope, p-value or each LM.
# Problem: I took some examples online to try and fit to my data but the code doesnt work.
```{r}
library(dplyr)
library(broom)
library(tsibble)
```

```{r, eval=FALSE}
# This is the code example that I used. The link is https://community.rstudio.com/t/how-to-calculate-slope-with-conditions-in-r/36053.
df %>% 
    group_nest(Source.Name, visbility, soundvolume) %>% 
    mutate(model = map(data, ~lm(m ~ stim_ending_t, data = .x))) %>% 
    mutate(slope = map_dbl(model, ~tidy(.x)$estimate[2]))
```

```{r, eval=FALSE}
C14_E1_ts <- as.tibble(C14_E1)
C14_E1_ts
E1_trial <- C14_E1_ts %>% 
  ungroup() %>%
  group_by(`sorting population`, `Vial code`)  %>%
  mutate(model = map(data, ~lm(DPM2~`Cells sorted`, data = .))) %>%
  mutate(slope = map_dbl(model, ~tidy(.)$estimate[2]))
E1_trial
```

\pagebreak

# Daniel solution

A few things:

* Please read in detail R for data science chapter on grouping data: https://r4ds.had.co.nz/transform.html
* Please read in detail R for data science chpater on joining data:  https://r4ds.had.co.nz/relational-data.html
* You can also go back to my class here: https://vaulot.github.io/course-ntu-data-science-2020/R-session-04-data_wrangling.html
* When you group data you must explicty tell which operation you want to perform (e.g. n() for counting, sum(), mean ()). If not no need to group data
* Make your code general from the start so that to extend to all cases, no need to rewrite it.  
* It is much better to rename immediately your varibales in a clean way

## Read the data

```{r}
C14_DPM <- readxl::read_excel("TAN1810 Adriana samples complete _final_AGR_1.0.xlsx", sheet = "Sheet1") %>%  # Explicit name and not position
     select ( EXP, SAMPLE, `Vial code`, `sorting population`, `Cells sorted`, DPM1) %>%   # Can add more variables latter
     rename(exp = EXP, 
            sample = SAMPLE, 
            vial = `Vial code`, 
            population = `sorting population`, 
            cells_sorted = `Cells sorted`, 
            dpm = DPM1) %>% 
     filter(exp == 1)  # You will just need to remove this line to make the code valid for all experiments
```


## Substract the dark DPM

You need to make join based on the common variables 

```{r}
 C14_DPM_Dark <- C14_DPM %>% 
  filter(vial == "D") %>% 
  rename(dpm_dark = dpm) %>% 
  select(-vial) # Remove the vial column
C14_DPM_Dark


C14_DPM_corrected <- left_join(C14_DPM,C14_DPM_Dark ) %>% 
  filter (vial != "D") %>% 
  mutate(dpm_corrected = dpm - dpm_dark) %>% 
  filter(dpm_corrected >= 0) # Remove negative values
  
C14_DPM_corrected  
  
```

## Method 1 - Compute lm by grouping ABC together

### Plots

Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population)) +
  geom_point() + stat_smooth(method="lm") +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_1 <- C14_DPM_corrected %>%
  group_by(exp, sample, population) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_1 <- C14_DPM_model_1 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_1
  
```

## Method 2 - Compute lm for  ABC separately

### Plots
Do plots for each group. One regression line based on the EXP, Sample and Populations

```{r}
 ggplot(data = C14_DPM_corrected, aes(x=cells_sorted, y=dpm_corrected, color=population, shape=vial)) +
  geom_point() + stat_smooth(method="lm", se=FALSE) +
  facet_grid(rows=vars(exp), cols=vars(sample)) +
  scale_color_viridis_d()
```

### Do linear model

y = ax + b

See: https://cran.r-project.org/web/packages/broom/vignettes/broom_and_dplyr.html

```{r}
 C14_DPM_model_2 <- C14_DPM_corrected %>%
  group_by(exp, sample, population, vial) %>% 
  tidyr::nest() %>% 
  mutate(
    fit = purrr::map(data, ~ lm(dpm_corrected ~ cells_sorted, data = .x)),
    tidied = purrr::map(fit, tidy)
  ) %>% 
  unnest(tidied)

C14_DPM_model_output_2 <- C14_DPM_model_2 %>% 
  select(exp:population, term, estimate) %>% 
  pivot_wider(names_from="term", values_from ="estimate" ) %>% 
  rename (a = cells_sorted, b = `(Intercept)`)

C14_DPM_model_output_2
  
```